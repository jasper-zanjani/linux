# Bash

??? info "Videos"

    <iframe width="1095" height="616" src="https://www.youtube.com/embed/ERWVSci3kO0?si=m3ntIYXAxYAvFuVN" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

<div class="grid cards" markdown>


-   **Bash** is known for esoteric syntaxes:

    ```sh
    # Arithmetic expansion
    $((...))

    # Alias for test
    [ ... ]

    # Command substitution
    $( ... )

    # Variable substitution
    ${ ... }

    # String substitution
    ${STRING/SEARCH/REPLACE}

    # Variable slicing
    ${VAR:START:SIZE}

    # Brace expansion
    filename{,.new}
    ```

-   **Event designators** can be used to reference previous commands

    ```sh
    # Last argument from previous command
    !$

    # First argument from previous command
    !^

    # nth word (0-indexed) from previous command
    !!:$n

    # nth word of current command
    !#:$n

    # Repeat last command, deleting the first instance of $STRING
    ^$STRING

    # Repeat last command, substituting all instances of $STRING with $SUBSTITUTE
    ^$STRING^SUBSTITUTE^
    ```

    **Escape sequences** are used primarily to define colors for color output at the terminal.
    An escape sequence is composed of an **escape character** (i.e. `\e`, `\033`, `\x1B`) followed by **format code** and ending with "m".

    **Special variables**

    The variables **$@** and **$\*** are only distinguished only when they are quoted.

    ```sh
    # All command-line arguments as a single word
    $@

    # All command-line arguments as separate words
    $*
    ```

</div>


## Loops

The body of all loops is bracketed between **do** and **done**.

<div class="grid cards" markdown>

-   Sequences of numbers can be generated by placing a number range between single braces

    ```sh
    for i in {01..07}
    do 
        # Doing stuff...
    done
    ```

-   Spaces delimit elements of an array

    ```sh
    for i in 1 2 3 4 5
    do 
        # Doing stuff...
    done
    ```


-   Extracting audio from mp4 files in the current working directory

    ```sh
    for f in *.mp4
    do 
        ffmpeg -i $f ${f/.mp4/.wav} 
    done
    ```

-   Traditional C-style for loop

    ```sh
    for ((i=0; i<N; i++))
    do 
        # Doing stuff...
    done
    ```

</div>






## Tasks

#### Configuration

- **/etc/profile** is the system config

- **$HOME/.bashrc** and **$HOME/.bash_profile** are the user configs

- Some distributions put additional configs in **$HOME/.bashrc.d/** but these are loaded by **source** statements within the bashrc.



The **set** and **shopt** internal commands are used for various shell settings.

<div class="grid cards" markdown>

```sh title="shopt"
# Disable case sensitivity
shopt -s nocasematch

# Navigate to directories without typing them
shopt -s autocd
```

```sh title="set"
# Enable debugging mode in a script
set +x

# Vi mode: press V in normal mode to open a file editor
set -o vi
```

</div>

```sh
# Start bash without loading startup configs
bash --norc 

# Start bash with a specified config file
bash --rcfile $BASHRC
```

<div class="grid cards" markdown>

-   #### Debugging

    Placing **-x** in the shebang of the script will produce the text of each line of a script being run,
    a feature called debugging mode.

    ---

    #### Keybindings


    Keybindings are supported by the **bind** internal command.
    This is used to great effect in **fzf**'s [keybinding scripts](https://thevaluable.dev/fzf-shell-integration/).


-   #### String manipulation

    ---

    ```sh title="String slicing"
    # Slice a substring $LENGTH characters long starting from position $INDEX from $STRING
    ${STRING:$INDEX:$LENGTH}
    ```

    To [**convert case**](https://medium.com/mkdir-awesome/case-transformation-in-bash-and-posix-with-examples-acdc1e0d0bc4):

    - **^** capitalize first letter
    - **^^** capitalize all letters
    - **,** lowercase first letter
    - **,,** lowercase all letters
    - **~** toggle first letter
    - **~~** toggle all letters

-   #### Arithmetic

    ---

    Mathematical expressions between **$((** and **))** are evaluated by bash.

    ```sh
    test $(( 2+2 )) -eq 4 # => 0 (true)
    ```

    Hexadecimal literals are prefixed with **0x** and octal numbers begin with **0**.
    **Number literals** can be defined on various number bases by prefixing the literal with **r#** where **r** is the base, 
    i.e. **`2#`** (binary), **`32#`** (base-32) etc.

    ```sh
    # 2 + 2 = 4
    test $(( 2#10 + 2#10 )) -eq 2#100

    # 4 + 4 = 8
    test $(( 4+4 )) -eq 010
    ```

-   #### Heredocs

    ---

    **Here documents** (**heredocs**) or **here strings** refer to a method of passing multiline strings to commands in bash.

    ```sh
    # Type out a block of text that is then saved to a file
    cat << EOF > hello.sh
    Hello, World!**xone**
    EOF
    ```

    ```sh
    # <<- ignores leading tabs, allowing the string to be indented in scripts
    cat <<- EOF > hello.sh
        Hello, World!
        EOF
    ```

-   #### Interactive text input

    ---

    The **read** command is used to capture user input at the terminal.
    It often appears with **-p**, which is used to provide a prompt.

    ```sh
    read -p "Enter name: "
    echo "Hello, ${REPLY:-World}!"
    ```

    If no variable **name** is provided at the end of the command, the input is stored in **$REPLY**.

    ```sh
    read -p "Backup another server? (y/n)" -n 1 CONFIRMATION
    ["$CONFIRMATION"="y"] || break
    ```

    Multiple items can be stored by using **-a** to declare an [array](#array) variable.

    ```sh
    read -p "List of users to delete, separated by ',': " -a USERS
    for user in ${USERS[*]}; do
        echo $user
    done
    ```

    Input will cease when the **delimiter** is encountered (newline by default), but a different delimiter can be defined with **-d**.

</div>

### Command-line parsing

Command-line arguments are available as the positional arguments **$1**, **$2**, etc. with the script itself being **$0**.
Handling command-line arguments is conventionally done with the **shift** command in a while loop.

The special variables **$\*** and **$@** represent all arguments, as a single string and as an array respectively.



<div class="grid cards" markdown>

-   #### Flow control

    ---

    Bash syntax supports a variety of methods to handle simple command-line arguments, such as exiting if no arguments were provided.

    ```sh
    if [ $# != 2 ]; then 
        echo "..."
    fi # (1)

    if [ ! -z "$2" ]; then 
        echo "..."
    fi # (3)

    [ -z "$1" ] && echo "..." # (2)
    ```

    1. From Sobell p. 548
    2. [Source](https://youtu.be/ksAfmJfdub0) 
    3. [Source](https://coderwall.com/p/kq9ghg/yakuake-scripting) 



-   #### getopts

    ---

    ```sh title="Representative usage"
    OPTSTRING=":ab:"
    while getopts ${OPTSTRING} OPTIONS; do
        case ${OPTIONS} in
            a) echo "Option -a triggered" ;;
            b) echo "Option -b triggered: ${OPTARG}" ;;
            :) echo "Option -${OPTARG} requires an argument" ;;
            ?) echo "Invalid option: -${OPTARG}." ;;
        esac
    done

    shift $((OPTIND - 1))
    ```

    - **OPTSTRING** is a string defining the available options.
    Usually a sequence of letters, if a letter is followed by a colon **:** then an argument is required.
    If the first character of OPTSTRING is a colon then the error message is silenced.

    - **OPTIONS** contains the processing result and is used in the case expression to determine program behavior.
    If an invalid option is provided, "?" is assigned to OPTIONS.
    If an argument is missing to a valid option, ":" is assigned to OPTIONS.

    - **OPTARG** is a builtin variable referencing the argument to a (valid) option.
    If an invalid option is provided, or if a required argument to a valid option is missing, the option itself is assigned to OPTARG.

    - The enclosing **while loop** iterates over each option provided in the command-line until they are exhausted.

    

    ??? info "OPTIND"

        **OPTIND** is a variable which is set to the value of the next option to be parsed by getopts on the next iteration of the loop.
        So on the first iteration OPTIND will be set to 2 if the option takes no argument and 3 if it does, and on every iteration OPTIND is incremented accordingly.

        OPTIND can be mostly ignored when using getopts within a script.
        However, if getopts is within a function then the OPTIND variable must be declared local.

        ```sh
        local OPTIND
        ```

        Because it is a global variable, OPTIND will [persist](https://eklitzke.org/using-local-optind-with-bash-getopts) when using it within a shell function and cause further executions to start from the wrong OPTIND value.
        The solution is to manually unset OPTID after execution, reset it to 1 before the following execution, or to make its scope local.


    ??? info "Resources"

        - [KodeKloud - How to use bash getopts with examples](https://kodekloud.com/blog/bash-getopts/)

    #### getopt

    Unlike [getopts](#getopts), **getopt** is a GNU utility.

</div>

and **argp\_parse** reorder the elements of **argv** by default, but this behavior can be suppressed by setting the **`_POSIX_OPTION_ORDER`** environment variable


## Examples

<div class="grid cards" markdown>

-   #### Hello, World!

    ---

    Within a variable substituion, placing **:-** after the identifier allows a default value to be provided if the variable is empty.

    ```sh title="Default value"
    --8<-- "includes/Tasks/bash/hw-default.sh"
    ```

    ```sh title="Interactive"
    --8<-- "includes/Tasks/bash/hw-interactive.sh"
    ```

    ```sh title="getopts"
    --8<-- "includes/Tasks/bash/hw-getopts.sh"
    ```


-   #### Set $PATH

    ---

    ```sh
    --8<-- "includes/Tasks/bash/path.sh"
    ```


</div>

#### Tag audio with metadata

```sh
--8<-- "includes/Tasks/bash/tag.sh"
```

#### Helper functions

Here is an example of a function I created to help me open deeply nested notes files using the **$EDITOR** environment variable.

```sh
--8<-- "includes/Tasks/bash/note.sh"
```

Trade blotter:

```sh
--8<-- "includes/Tasks/bash/trade.sh"
```
