# Bash

<div class="grid cards" markdown>

-   **Internal commands**

    ---

    Various internal commands are available to manipulate bash settings.


    === "bind"


        ```sh
        # Display keybindings
        bind -P
        bind -p
        ```

    === "set"

        ```sh
        # Enable debugging mode in a script
        set +x

        # Vi mode: press V in normal mode to open a file editor
        set -o vi
        ```

    === "shopt"

        ```sh
        # Disable case sensitivity
        shopt -s nocasematch

        # Navigate to directories without typing them
        shopt -s autocd
        ```

    === ":material-tools: config"

        - **/etc/profile** is the system config

        - **$HOME/.bashrc** and **$HOME/.bash_profile** are the user configs

        - Some distributions put additional configs in **$HOME/.bashrc.d/** but these are loaded by **source** statements within the bashrc.

    === ":octicons-command-palette-24: options"

        ```sh
        # Start bash without loading startup configs
        bash --norc 

        # Start bash with a specified config file
        bash --rcfile $BASHRC
        ```

-   **Keybindings**

    ---

    - ++alt+b++ previous word
    - ++alt+f++ next word

</div>



**Bash** is known for esoteric syntaxes:

<div class="grid cards" markdown>


```sh title="Arithmetic expansion"
$((...))
```

```sh title="Test"
[ ... ]
```

```sh title="Command substitution"
$( ... )
```

```sh title="Variable substitution"
${ ... }
```

```sh title="String substitution"
${STRING/SEARCH/REPLACE}
```

```sh title="Variable slicing"
${VAR:START:SIZE}
```

```sh title="Brace expansion"
filename{,.new}
```

</div>

**Event designators** can be used to reference previous commands


<div class="grid cards" markdown>

```sh
# Last argument from previous command
!$
```

```sh
# First argument from previous command
!^
```

```sh
# nth word (0-indexed) from previous command
!!:$n
```

```sh
# Repeat last command, deleting the first instance of $STRING
^$STRING
```

```sh
# Repeat last command, substituting all instances of $STRING with $SUBSTITUTE
^$STRING^SUBSTITUTE^
```

```sh
# nth word of current command
!#:$n
```

</div>

**Escape sequences** are used primarily to define colors for color output at the terminal.
An escape sequence is composed of an **escape character** (i.e. `\e`, `\033`, `\x1B`) followed by **format code** and ending with "m".

**Special variables**

The variables **$@** and **$\*** are only distinguished only when they are quoted.

```sh
# All command-line arguments as a single word
$@

# All command-line arguments as separate words
$*
```





## Loops

The body of all loops is bracketed between **do** and **done**.

<div class="grid cards" markdown>

-   Sequences of numbers can be generated by placing a number range between single braces

    ```sh
    for i in {01..07}
    do 
        # Doing stuff...
    done
    ```

-   Spaces delimit elements of an array

    ```sh
    for i in 1 2 3 4 5
    do 
        # Doing stuff...
    done
    ```


-   Extracting audio from mp4 files in the current working directory

    ```sh
    for f in *.mp4
    do 
        ffmpeg -i $f ${f/.mp4/.wav} 
    done
    ```

-   Traditional C-style for loop

    ```sh
    for ((i=0; i<N; i++))
    do 
        # Doing stuff...
    done
    ```

</div>






## Tasks


<div class="grid cards" markdown>

-   #### Debugging

    Placing **-x** in the shebang of the script will produce the text of each line of a script being run,
    a feature called debugging mode.

    ---

    #### Keybindings


    Keybindings are supported by the **bind** internal command.
    This is used to great effect in **fzf**'s [keybinding scripts](https://thevaluable.dev/fzf-shell-integration/).


-   #### String manipulation

    ---

    ```sh title="String slicing"
    # Slice a substring $LENGTH characters long starting from position $INDEX from $STRING
    ${STRING:$INDEX:$LENGTH}
    ```

    To [**convert case**](https://medium.com/mkdir-awesome/case-transformation-in-bash-and-posix-with-examples-acdc1e0d0bc4):

    - **^** capitalize first letter
    - **^^** capitalize all letters
    - **,** lowercase first letter
    - **,,** lowercase all letters
    - **~** toggle first letter
    - **~~** toggle all letters

-   #### Arithmetic

    ---

    Mathematical expressions between **$((** and **))** are evaluated by bash.

    ```sh
    test $(( 2+2 )) -eq 4 # => 0 (true)
    ```

    Hexadecimal literals are prefixed with **0x** and octal numbers begin with **0**.
    **Number literals** can be defined on various number bases by prefixing the literal with **r#** where **r** is the base, 
    i.e. **`2#`** (binary), **`32#`** (base-32) etc.

    ```sh
    # 2 + 2 = 4
    test $(( 2#10 + 2#10 )) -eq 2#100

    # 4 + 4 = 8
    test $(( 4+4 )) -eq 010
    ```

-   #### Heredocs

    ---

    **Here documents** (**heredocs**) or **here strings** refer to a method of passing multiline strings to commands in bash.

    ```sh
    # Type out a block of text that is then saved to a file
    cat << EOF > hello.sh
    Hello, World!**xone**
    EOF
    ```

    ```sh
    # <<- ignores leading tabs, allowing the string to be indented in scripts
    cat <<- EOF > hello.sh
        Hello, World!
        EOF
    ```

-   #### Interactive text input

    ---

    The **read** command is used to capture user input at the terminal.
    It often appears with **-p**, which is used to provide a prompt.

    ```sh
    read -p "Enter name: "
    echo "Hello, ${REPLY:-World}!"
    ```

    If no variable **name** is provided at the end of the command, the input is stored in **$REPLY**.

    ```sh
    read -p "Backup another server? (y/n)" -n 1 CONFIRMATION
    ["$CONFIRMATION"="y"] || break
    ```

    Multiple items can be stored by using **-a** to declare an [array](#array) variable.

    ```sh
    read -p "List of users to delete, separated by ',': " -a USERS
    for user in ${USERS[*]}; do
        echo $user
    done
    ```

    Input will cease when the **delimiter** is encountered (newline by default), but a different delimiter can be defined with **-d**.

</div>

### Command-line parsing

<div class="grid cards" markdown>

-   

    Command-line arguments are available as the positional arguments **$1**, **$2**, etc. with the script itself being **$0**.
    Handling command-line arguments is conventionally done with the **shift** command in a while loop.

    The special variables **$\*** and **$@** represent all arguments, as a single string and as an array respectively.

    Bash syntax supports a variety of methods to handle simple command-line arguments, such as exiting if no arguments were provided.

    ```sh
    if [ $# != 2 ]; then 
        echo "..."
    fi # (1)

    if [ ! -z "$2" ]; then 
        echo "..."
    fi # (3)

    [ -z "$1" ] && echo "..." # (2)
    ```

    1. From Sobell p. 548
    2. [Source](https://youtu.be/ksAfmJfdub0) 
    3. [Source](https://coderwall.com/p/kq9ghg/yakuake-scripting) 


!!! info "getopts"

    --8<-- "includes/Commands/b/bash-getopts.md"

</div>

## Examples

<div class="grid cards" markdown>

-   #### Hello, World!

    ---

    Within a variable substitution, placing **:-** after the identifier allows a default value to be provided if the variable is empty.

    ```sh title="Default value"
    --8<-- "includes/Tasks/bash/hw-default.sh"
    ```

    ```sh title="Interactive"
    --8<-- "includes/Tasks/bash/hw-interactive.sh"
    ```

    ```sh title="getopts"
    --8<-- "includes/Tasks/bash/hw-getopts.sh"
    ```


-   #### Set $PATH

    ---

    ```sh
    --8<-- "includes/Tasks/bash/path.sh"
    ```


</div>

#### Tag audio with metadata

```sh
--8<-- "includes/Tasks/bash/tag.sh"
```

